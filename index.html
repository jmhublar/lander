<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Moonlander</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { width: 100%; height: 100%; overflow: hidden; background: #000; }
  canvas { display: block; width: 100%; height: 100%; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
// ─── Setup ───────────────────────────────────────────────────────────
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

function resize() {
  canvas.width = document.documentElement.clientWidth || window.innerWidth;
  canvas.height = document.documentElement.clientHeight || window.innerHeight;
}
window.addEventListener('resize', resize);
resize();
// Re-resize after a tick in case layout wasn't ready
setTimeout(resize, 50);

// ─── Audio ───────────────────────────────────────────────────────────
let audioCtx = null;
let thrustNode = null;
let thrustGain = null;
let thrustFilter = null;
let audioStarted = false;

function initAudio() {
  if (audioStarted) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  audioStarted = true;

  // Thrust sound: filtered noise (rocket rumble)
  const bufferSize = 2 * audioCtx.sampleRate;
  const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const output = noiseBuffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) {
    output[i] = Math.random() * 2 - 1;
  }

  thrustNode = audioCtx.createBufferSource();
  thrustNode.buffer = noiseBuffer;
  thrustNode.loop = true;

  // Low-pass filter for deep rumble
  thrustFilter = audioCtx.createBiquadFilter();
  thrustFilter.type = 'lowpass';
  thrustFilter.frequency.value = 150;
  thrustFilter.Q.value = 1;

  // Second filter for body
  const midFilter = audioCtx.createBiquadFilter();
  midFilter.type = 'bandpass';
  midFilter.frequency.value = 80;
  midFilter.Q.value = 0.5;

  thrustGain = audioCtx.createGain();
  thrustGain.gain.value = 0;

  thrustNode.connect(thrustFilter);
  thrustFilter.connect(thrustGain);

  // Also add a parallel mid-range path for fuller sound
  const thrustNode2 = audioCtx.createBufferSource();
  thrustNode2.buffer = noiseBuffer;
  thrustNode2.loop = true;
  const midGain = audioCtx.createGain();
  midGain.gain.value = 0.3;
  thrustNode2.connect(midFilter);
  midFilter.connect(midGain);
  midGain.connect(thrustGain);
  thrustNode2.start();

  thrustGain.connect(audioCtx.destination);
  thrustNode.start();
}

function playExplosionSound() {
  if (!audioCtx) return;
  // Short burst of filtered noise
  const bufLen = audioCtx.sampleRate * 0.8;
  const buf = audioCtx.createBuffer(1, bufLen, audioCtx.sampleRate);
  const data = buf.getChannelData(0);
  for (let i = 0; i < bufLen; i++) {
    data[i] = (Math.random() * 2 - 1) * (1 - i / bufLen);
  }
  const src = audioCtx.createBufferSource();
  src.buffer = buf;
  const filt = audioCtx.createBiquadFilter();
  filt.type = 'lowpass';
  filt.frequency.value = 400;
  filt.frequency.linearRampToValueAtTime(50, audioCtx.currentTime + 0.8);
  const gain = audioCtx.createGain();
  gain.gain.value = 0.6;
  gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.8);
  src.connect(filt);
  filt.connect(gain);
  gain.connect(audioCtx.destination);
  src.start();
}

function playLandingSound() {
  if (!audioCtx) return;
  // Gentle thud + rising chime
  const osc = audioCtx.createOscillator();
  osc.type = 'sine';
  osc.frequency.value = 200;
  osc.frequency.linearRampToValueAtTime(600, audioCtx.currentTime + 0.3);
  const gain = audioCtx.createGain();
  gain.gain.value = 0.3;
  gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + 0.5);

  // Thud
  const osc2 = audioCtx.createOscillator();
  osc2.type = 'sine';
  osc2.frequency.value = 60;
  const gain2 = audioCtx.createGain();
  gain2.gain.value = 0.4;
  gain2.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.2);
  osc2.connect(gain2);
  gain2.connect(audioCtx.destination);
  osc2.start();
  osc2.stop(audioCtx.currentTime + 0.2);
}

function updateThrustSound(isThrusting) {
  if (!thrustGain) return;
  const target = isThrusting ? 0.35 : 0;
  thrustGain.gain.value += (target - thrustGain.gain.value) * 0.1;
  // Modulate filter frequency slightly for variation
  if (isThrusting && thrustFilter) {
    thrustFilter.frequency.value = 120 + Math.random() * 60;
  }
}

// ─── Title Fanfare Loop ───────────────────────────────────────────
let marchPlaying = false;
let marchTimeout = null;
let marchOscillators = [];
let marchGainNode = null;

function playMarchTheme() {
  if (!audioCtx || marchPlaying) return;
  stopDeathMarchTheme();
  marchPlaying = true;

  // Master gain for the march
  marchGainNode = audioCtx.createGain();
  marchGainNode.gain.value = 0.25;
  marchGainNode.connect(audioCtx.destination);

  // Triumphant title fanfare in C major
  // Each note: [frequency, duration in ms, startTime in ms]
  const BPM = 140;
  const Q = 60000 / BPM; // quarter note ms
  const E = Q / 2;       // eighth note
  const H = Q * 2;       // half note
  const W = Q * 4;       // whole note

  // Frequencies (Hz)
  const C4=261.63, D4=293.66, E4=329.63, F4=349.23, G4=392.00, A4=440.00, B4=493.88;
  const C5=523.25, D5=587.33, E5=659.25, G5=783.99;
  const C3=130.81, G3=196.00, F3=174.61, E3=164.81, A3=220.00, B3=246.94;

  // Melody line - heroic march fanfare
  const melody = [
    [C4, E, 0], [C4, E, E], [G4, Q, E*2], [G4, E, E*2+Q], [A4, E, E*3+Q],
    [G4, Q, E*4+Q], [E4, Q, E*4+Q+Q],
    [C4, E, E*4+Q+Q+Q], [C4, E, E*5+Q+Q+Q], [G4, Q, E*6+Q+Q+Q],
    [G4, E, E*6+Q*2+Q], [A4, E, E*7+Q*2+Q], [G4, H, E*8+Q*2+Q],
    // Second phrase - ascending triumphant
    [E4, E, E*8+Q*2+Q+H], [F4, E, E*9+Q*2+Q+H], [G4, E, E*10+Q*2+Q+H],
    [A4, Q, E*11+Q*2+Q+H], [G4, E, E*11+Q*3+Q+H], [E4, E, E*12+Q*3+Q+H],
    [C5, Q+E, E*13+Q*3+Q+H], [B4, E, E*13+Q*4+Q+E+H],
    [A4, E, E*14+Q*4+Q+E+H], [G4, H, E*15+Q*4+Q+E+H],
    // Resolve
    [E4, E, E*15+Q*4+Q+E+H+H], [D4, E, E*16+Q*4+Q+E+H+H],
    [C4, H+Q, E*17+Q*4+Q+E+H+H],
  ];

  // Bass line - rhythmic march bass
  const bassLine = [
    [C3, Q, 0], [G3, Q, Q], [C3, Q, Q*2], [G3, Q, Q*3],
    [C3, Q, Q*4], [G3, Q, Q*5], [C3, Q, Q*6], [G3, Q, Q*7],
    [A3, Q, Q*8], [E3, Q, Q*9], [F3, Q, Q*10], [G3, Q, Q*11],
    [C3, Q, Q*12], [G3, Q, Q*13], [C3, H, Q*14],
  ];

  // Snare hits (noise bursts) on beats 2 and 4
  const snareHits = [];
  for (let i = 0; i < 16; i++) {
    if (i % 2 === 1) snareHits.push(i * Q);
  }

  // Calculate total loop duration
  const loopDuration = Q * 16;

  function scheduleLoop() {
    if (!marchPlaying) return;
    const now = audioCtx.currentTime;

    // Schedule melody
    melody.forEach(([freq, dur, start]) => {
      const osc = audioCtx.createOscillator();
      osc.type = 'square';
      osc.frequency.value = freq;
      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0, now + start / 1000);
      g.gain.linearRampToValueAtTime(0.15, now + start / 1000 + 0.01);
      g.gain.setValueAtTime(0.15, now + (start + dur * 0.7) / 1000);
      g.gain.linearRampToValueAtTime(0, now + (start + dur) / 1000);
      osc.connect(g);
      g.connect(marchGainNode);
      osc.start(now + start / 1000);
      osc.stop(now + (start + dur + 10) / 1000);
      marchOscillators.push(osc);
    });

    // Schedule bass
    bassLine.forEach(([freq, dur, start]) => {
      const osc = audioCtx.createOscillator();
      osc.type = 'triangle';
      osc.frequency.value = freq;
      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0, now + start / 1000);
      g.gain.linearRampToValueAtTime(0.2, now + start / 1000 + 0.01);
      g.gain.setValueAtTime(0.2, now + (start + dur * 0.6) / 1000);
      g.gain.linearRampToValueAtTime(0, now + (start + dur) / 1000);
      osc.connect(g);
      g.connect(marchGainNode);
      osc.start(now + start / 1000);
      osc.stop(now + (start + dur + 10) / 1000);
      marchOscillators.push(osc);
    });

    // Schedule snare-like bursts
    snareHits.forEach(start => {
      const bufLen = Math.floor(audioCtx.sampleRate * 0.05);
      const buf = audioCtx.createBuffer(1, bufLen, audioCtx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i = 0; i < bufLen; i++) {
        data[i] = (Math.random() * 2 - 1) * (1 - i / bufLen);
      }
      const src = audioCtx.createBufferSource();
      src.buffer = buf;
      const hp = audioCtx.createBiquadFilter();
      hp.type = 'highpass';
      hp.frequency.value = 2000;
      const g = audioCtx.createGain();
      g.gain.value = 0.12;
      src.connect(hp);
      hp.connect(g);
      g.connect(marchGainNode);
      src.start(now + start / 1000);
      marchOscillators.push(src);
    });

    // Schedule next loop
    marchTimeout = setTimeout(scheduleLoop, loopDuration - 50);
  }

  scheduleLoop();
}

function stopMarchTheme() {
  marchPlaying = false;
  if (marchTimeout) {
    clearTimeout(marchTimeout);
    marchTimeout = null;
  }
  // Fade out the march
  if (marchGainNode) {
    marchGainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
    setTimeout(() => {
      marchOscillators.forEach(o => { try { o.stop(); } catch(e) {} });
      marchOscillators = [];
    }, 400);
  }
}

// ─── Game Over Death March ─────────────────────────────────────────
let deathMarchPlaying = false;
let deathMarchTimeout = null;
let deathMarchOscillators = [];
let deathMarchGainNode = null;

function playDeathMarchTheme() {
  if (!audioCtx || deathMarchPlaying) return;
  stopMarchTheme();
  deathMarchPlaying = true;

  deathMarchGainNode = audioCtx.createGain();
  deathMarchGainNode.gain.value = 0.22;
  deathMarchGainNode.connect(audioCtx.destination);

  // Funeral march feel in D minor with clockwork-like ticks.
  const BPM = 70;
  const Q = 60000 / BPM;
  const E = Q / 2;
  const H = Q * 2;

  const A2 = 110.0;
  const C3 = 130.81;
  const D3 = 146.83;
  const E3 = 164.81;
  const F3 = 174.61;
  const G3 = 196.0;
  const A3 = 220.0;
  const C4 = 261.63;
  const D4 = 293.66;
  const E4 = 329.63;
  const F4 = 349.23;
  const G4 = 392.0;
  const A4 = 440.0;

  const melody = [
    [D4, Q, 0], [F4, Q, Q], [A4, H, Q * 2],
    [G4, Q, Q * 4], [F4, Q, Q * 5], [E4, H, Q * 6],
    [D4, Q, Q * 8], [F4, Q, Q * 9], [A4, Q, Q * 10], [C4, Q, Q * 11],
    [A3, Q, Q * 12], [G3, Q, Q * 13], [F3, H, Q * 14],
  ];

  const bassLine = [
    [D3, H, 0], [A2, H, Q * 2], [D3, H, Q * 4], [C3, H, Q * 6],
    [D3, H, Q * 8], [A2, H, Q * 10], [F3, H, Q * 12], [D3, H, Q * 14],
  ];

  const clockTicks = [];
  for (let i = 0; i < 32; i++) {
    clockTicks.push(i * E);
  }

  const loopDuration = Q * 16;

  function scheduleLoop() {
    if (!deathMarchPlaying) return;
    const now = audioCtx.currentTime;

    melody.forEach(([freq, dur, start]) => {
      const osc = audioCtx.createOscillator();
      osc.type = 'sawtooth';
      osc.frequency.value = freq;
      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0, now + start / 1000);
      g.gain.linearRampToValueAtTime(0.1, now + start / 1000 + 0.02);
      g.gain.setValueAtTime(0.1, now + (start + dur * 0.8) / 1000);
      g.gain.linearRampToValueAtTime(0, now + (start + dur) / 1000);
      osc.connect(g);
      g.connect(deathMarchGainNode);
      osc.start(now + start / 1000);
      osc.stop(now + (start + dur + 20) / 1000);
      deathMarchOscillators.push(osc);
    });

    bassLine.forEach(([freq, dur, start]) => {
      const osc = audioCtx.createOscillator();
      osc.type = 'triangle';
      osc.frequency.value = freq;
      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0, now + start / 1000);
      g.gain.linearRampToValueAtTime(0.16, now + start / 1000 + 0.02);
      g.gain.setValueAtTime(0.16, now + (start + dur * 0.75) / 1000);
      g.gain.linearRampToValueAtTime(0, now + (start + dur) / 1000);
      osc.connect(g);
      g.connect(deathMarchGainNode);
      osc.start(now + start / 1000);
      osc.stop(now + (start + dur + 20) / 1000);
      deathMarchOscillators.push(osc);
    });

    clockTicks.forEach((start, i) => {
      const osc = audioCtx.createOscillator();
      osc.type = 'square';
      osc.frequency.value = i % 2 === 0 ? 1650 : 1200;
      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0, now + start / 1000);
      g.gain.linearRampToValueAtTime(0.03, now + start / 1000 + 0.004);
      g.gain.linearRampToValueAtTime(0, now + start / 1000 + 0.035);
      osc.connect(g);
      g.connect(deathMarchGainNode);
      osc.start(now + start / 1000);
      osc.stop(now + start / 1000 + 0.05);
      deathMarchOscillators.push(osc);
    });

    deathMarchTimeout = setTimeout(scheduleLoop, loopDuration - 50);
  }

  scheduleLoop();
}

function stopDeathMarchTheme() {
  deathMarchPlaying = false;
  if (deathMarchTimeout) {
    clearTimeout(deathMarchTimeout);
    deathMarchTimeout = null;
  }
  if (deathMarchGainNode && audioCtx) {
    deathMarchGainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
    setTimeout(() => {
      deathMarchOscillators.forEach(o => { try { o.stop(); } catch (e) {} });
      deathMarchOscillators = [];
    }, 400);
  }
}

// ─── 80s Arcade Start Jingle ──────────────────────────────────────
function playStartJingle() {
  if (!audioCtx) return;

  // Classic 80s arcade startup: rapid ascending arpeggios with square waves
  const now = audioCtx.currentTime;
  const jingleGain = audioCtx.createGain();
  jingleGain.gain.value = 0.2;
  jingleGain.connect(audioCtx.destination);

  // Notes: fast ascending arpeggio → held chord → descending cascade → final chord
  const notes = [
    // Rapid ascending arpeggio (16th notes)
    { f: 262, t: 0,    d: 0.06, wave: 'square' },
    { f: 330, t: 0.07, d: 0.06, wave: 'square' },
    { f: 392, t: 0.14, d: 0.06, wave: 'square' },
    { f: 523, t: 0.21, d: 0.06, wave: 'square' },
    // Brief pause, then second arpeggio higher
    { f: 330, t: 0.35, d: 0.06, wave: 'square' },
    { f: 392, t: 0.42, d: 0.06, wave: 'square' },
    { f: 523, t: 0.49, d: 0.06, wave: 'square' },
    { f: 659, t: 0.56, d: 0.06, wave: 'square' },
    // Triumphant held notes
    { f: 784, t: 0.70, d: 0.20, wave: 'square' },
    { f: 659, t: 0.70, d: 0.20, wave: 'square' },  // harmony
    { f: 523, t: 0.70, d: 0.20, wave: 'triangle' }, // bass
    // Final resolving chord
    { f: 1047, t: 0.95, d: 0.35, wave: 'square' },
    { f: 784,  t: 0.95, d: 0.35, wave: 'square' },
    { f: 523,  t: 0.95, d: 0.35, wave: 'triangle' },
    { f: 262,  t: 0.95, d: 0.35, wave: 'triangle' },
  ];

  notes.forEach(n => {
    const osc = audioCtx.createOscillator();
    osc.type = n.wave;
    osc.frequency.value = n.f;
    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0, now + n.t);
    g.gain.linearRampToValueAtTime(0.18, now + n.t + 0.01);
    g.gain.setValueAtTime(0.18, now + n.t + n.d * 0.7);
    g.gain.linearRampToValueAtTime(0, now + n.t + n.d);
    osc.connect(g);
    g.connect(jingleGain);
    osc.start(now + n.t);
    osc.stop(now + n.t + n.d + 0.05);
  });

  // Fade out the jingle gain at the end
  jingleGain.gain.setValueAtTime(0.2, now + 1.3);
  jingleGain.gain.linearRampToValueAtTime(0, now + 1.4);
}

// ─── Constants ───────────────────────────────────────────────────────
const GRAVITY = 0.006;
const THRUST = 0.025;
const ROTATION_SPEED = 0.015;
const MAX_SAFE_VY = 1.0;
const MAX_SAFE_VX = 0.6;
const MAX_SAFE_ANGLE = 0.35; // ~20 degrees
const LANDER_SIZE = 14;
const BOUNDARY_MARGIN = 0.15; // boundary at 15% beyond screen edges
const STARTING_LIVES = 3;
const HIGH_SCORE_STORAGE_KEY = 'moonlander.highScore';

// ─── Game State ──────────────────────────────────────────────────────
let state = 'title'; // title, playing, landed, crashed, gameOver
let level = 1;
let score = 0;
let lives = STARTING_LIVES;
let lander, terrain, landingPads, stars;
let particles = [];
let keys = {};
let messageTimer = 0;
let camera = { x: 0, y: 0, zoom: 1, targetZoom: 1 };
let highScore = loadHighScore();

function loadHighScore() {
  try {
    const savedValue = window.localStorage.getItem(HIGH_SCORE_STORAGE_KEY);
    if (savedValue === null) return 0;
    const parsedValue = Number.parseInt(savedValue, 10);
    if (!Number.isFinite(parsedValue) || parsedValue < 0) return 0;
    return parsedValue;
  } catch {
    return 0;
  }
}

function saveHighScore(value) {
  try {
    window.localStorage.setItem(HIGH_SCORE_STORAGE_KEY, String(value));
  } catch {
  }
}

function syncHighScore() {
  if (score > highScore) {
    highScore = score;
    saveHighScore(highScore);
  }
}

// ─── Input ───────────────────────────────────────────────────────────
window.addEventListener('keydown', e => {
  keys[e.code] = true;
  initAudio();
  // Start march theme on first interaction if on title
  if (state === 'title' && !marchPlaying && audioStarted) {
    stopDeathMarchTheme();
    playMarchTheme();
  }
  if (state === 'title' && e.code === 'Space') {
    stopMarchTheme();
    stopDeathMarchTheme();
    playStartJingle();
    lives = STARTING_LIVES;
    score = 0;
    startLevel(1);
  }
  if ((state === 'landed' || state === 'crashed') && e.code === 'Space') {
    if (state === 'landed') {
      startLevel(level + 1);
    } else {
      startLevel(level);
    }
  }
  if (state === 'gameOver' && e.code === 'Space') {
    // Return to title
    stopDeathMarchTheme();
    state = 'title';
    lives = STARTING_LIVES;
    score = 0;
    level = 1;
    stars = generateStars();
    playMarchTheme();
  }
});
window.addEventListener('keyup', e => { keys[e.code] = false; });
// Also start march on click/tap (for mobile or if user clicks first)
window.addEventListener('click', () => {
  initAudio();
  if (state === 'title' && !marchPlaying && audioStarted) {
    stopDeathMarchTheme();
    playMarchTheme();
  }
}, { once: false });

// ─── Procedural Terrain ─────────────────────────────────────────────
function generateTerrain(lvl) {
  const w = canvas.width;
  const h = canvas.height;
  const seed = lvl * 7919;
  const rng = mulberry32(seed);

  const points = [];
  // Extra terrain on each side for zoom-out (~3x screen width each side)
  const segCount = 60 + Math.floor(lvl * 10);
  const segWidth = w / segCount;
  const extraSegs = Math.ceil(segCount * 3);
  const totalSegs = segCount + extraSegs * 2;

  // Determine number of landing pads (fewer as level increases)
  const padCount = Math.max(1, 3 - Math.floor(lvl / 3));
  const padWidth = Math.max(3, 6 - Math.floor(lvl / 2)); // in segments

  // Choose pad positions within the main visible area (avoid edges)
  const pads = [];
  const usedSegs = new Set();
  for (let p = 0; p < padCount; p++) {
    let attempts = 0;
    let pos;
    do {
      pos = Math.floor(rng() * (segCount - padWidth - 10)) + 5;
      attempts++;
    } while (attempts < 100 && [...usedSegs].some(s => Math.abs(s - pos) < padWidth + 5));
    pads.push({ start: pos + extraSegs, width: padWidth });
    for (let i = pos; i < pos + padWidth; i++) usedSegs.add(i);
  }

  // Generate heightmap
  const baseHeight = h * 0.75;
  const roughness = 0.3 + lvl * 0.05;
  let currentHeight = baseHeight + (rng() - 0.5) * h * 0.1;

  for (let i = 0; i <= totalSegs; i++) {
    const x = (i - extraSegs) * segWidth;
    // Check if this segment is part of a landing pad
    const pad = pads.find(p => i >= p.start && i <= p.start + p.width);
    if (pad) {
      // Flat surface for landing pad
      if (i === pad.start) {
        pad.y = currentHeight;
      }
      points.push({ x, y: pad.y });
    } else {
      currentHeight += (rng() - 0.5) * 40 * roughness;
      currentHeight = Math.max(h * 0.5, Math.min(h * 0.9, currentHeight));
      points.push({ x, y: currentHeight });
    }
  }

  // Build landing pad metadata (convert from segment index to world x)
  const landingPadsMeta = pads.map(p => ({
    x1: (p.start - extraSegs) * segWidth,
    x2: (p.start + p.width - extraSegs) * segWidth,
    y: p.y,
    cx: (p.start + p.width / 2 - extraSegs) * segWidth
  }));

  return { points, landingPads: landingPadsMeta };
}

// ─── Seeded RNG ──────────────────────────────────────────────────────
function mulberry32(a) {
  return function() {
    a |= 0; a = a + 0x6D2B79F5 | 0;
    let t = Math.imul(a ^ a >>> 15, 1 | a);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

// ─── Stars ───────────────────────────────────────────────────────────
function generateStars() {
  const s = [];
  for (let i = 0; i < 200; i++) {
    s.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height * 0.7,
      size: Math.random() * 1.5 + 0.5,
      brightness: Math.random() * 0.5 + 0.5
    });
  }
  return s;
}

// ─── Particles ───────────────────────────────────────────────────────
function spawnThrustParticles(x, y, angle) {
  for (let i = 0; i < 2; i++) {
    const spread = (Math.random() - 0.5) * 0.5;
    particles.push({
      x, y,
      vx: -Math.sin(angle + spread) * (2 + Math.random() * 2),
      vy: Math.cos(angle + spread) * (2 + Math.random() * 2),
      life: 1.0,
      decay: 0.02 + Math.random() * 0.03,
      size: Math.random() * 3 + 1
    });
  }
}

function spawnExplosion(x, y) {
  for (let i = 0; i < 60; i++) {
    const a = Math.random() * Math.PI * 2;
    const speed = Math.random() * 4 + 1;
    particles.push({
      x, y,
      vx: Math.cos(a) * speed,
      vy: Math.sin(a) * speed,
      life: 1.0,
      decay: 0.01 + Math.random() * 0.02,
      size: Math.random() * 4 + 1,
      color: ['#ff4400', '#ff8800', '#ffcc00', '#ffffff'][Math.floor(Math.random() * 4)]
    });
  }
}

function spawnLandingParticles(x, y) {
  for (let i = 0; i < 30; i++) {
    const a = -Math.PI * Math.random();
    const speed = Math.random() * 2 + 0.5;
    particles.push({
      x, y,
      vx: Math.cos(a) * speed,
      vy: Math.sin(a) * speed,
      life: 1.0,
      decay: 0.015,
      size: Math.random() * 2 + 1,
      color: '#44ff88'
    });
  }
}

// ─── Init Level ──────────────────────────────────────────────────────
function startLevel(lvl) {
  level = lvl;
  state = 'playing';
  const t = generateTerrain(lvl);
  terrain = t.points;
  landingPads = t.landingPads;
  stars = generateStars();
  particles = [];

  // Spawn lander at top center
  lander = {
    x: canvas.width / 2,
    y: 60,
    vx: 0,
    vy: 0,
    angle: 0,
    thrusting: false,
    outOfBounds: false
  };

  camera = { x: 0, y: 0, zoom: 1, targetZoom: 1 };
}

// ─── Collision Detection ─────────────────────────────────────────────
function getTerrainYAtX(x) {
  for (let i = 0; i < terrain.length - 1; i++) {
    if (x >= terrain[i].x && x <= terrain[i + 1].x) {
      const t = (x - terrain[i].x) / (terrain[i + 1].x - terrain[i].x);
      return terrain[i].y + t * (terrain[i + 1].y - terrain[i].y);
    }
  }
  return canvas.height;
}

function checkLanding() {
  const footY = lander.y + LANDER_SIZE;
  const terrainY = getTerrainYAtX(lander.x);

  if (footY >= terrainY) {
    // Check if on a landing pad
    const pad = landingPads.find(p =>
      lander.x >= p.x1 + 5 && lander.x <= p.x2 - 5 &&
      Math.abs(footY - p.y) < 8
    );

    const safeLanding =
      Math.abs(lander.vy) <= MAX_SAFE_VY &&
      Math.abs(lander.vx) <= MAX_SAFE_VX &&
      Math.abs(lander.angle) <= MAX_SAFE_ANGLE;

    if (pad && safeLanding) {
      state = 'landed';
      lander.y = pad.y - LANDER_SIZE;
      lander.vx = 0;
      lander.vy = 0;
      lander.angle = 0;
      // Score based on precision and speed
      const vBonus = Math.floor((1 - Math.abs(lander.vy) / MAX_SAFE_VY) * 50);
      const aBonus = Math.floor((1 - Math.abs(lander.angle) / MAX_SAFE_ANGLE) * 50);
      const levelBonus = level * 100;
      score += levelBonus + vBonus + aBonus;
      syncHighScore();
      spawnLandingParticles(lander.x, pad.y);
      updateThrustSound(false);
      playLandingSound();
    } else {
      lives = Math.max(0, lives - 1);
      if (lives === 0) {
        state = 'gameOver';
        playDeathMarchTheme();
      } else {
        state = 'crashed';
      }
      spawnExplosion(lander.x, lander.y);
      updateThrustSound(false);
      playExplosionSound();
    }
  }

  // Check boundary — mark out of bounds (no more instant crash)
  const bLeft = -canvas.width * BOUNDARY_MARGIN;
  const bRight = canvas.width * (1 + BOUNDARY_MARGIN);
  const bTop = -canvas.height * BOUNDARY_MARGIN;
  if (lander.x < bLeft || lander.x > bRight || lander.y < bTop) {
    lander.outOfBounds = true;
  }
}

// ─── Update ──────────────────────────────────────────────────────────
function update() {
  if (state !== 'playing') {
    // Update particles even when not playing
    updateParticles();
    updateThrustSound(false);
    return;
  }

  // Input (disabled when out of bounds)
  if (!lander.outOfBounds) {
    if (keys['ArrowLeft'] || keys['KeyA']) lander.angle -= ROTATION_SPEED;
    if (keys['ArrowRight'] || keys['KeyD']) lander.angle += ROTATION_SPEED;
    lander.thrusting = keys['ArrowUp'] || keys['KeyW'];
  } else {
    lander.thrusting = false;
  }

  // Physics
  lander.vy += GRAVITY;

  if (lander.thrusting) {
    lander.vx += Math.sin(lander.angle) * THRUST;
    lander.vy -= Math.cos(lander.angle) * THRUST;
    // Thrust particles spawn from rear (bottom of lander in local space)
    // Local (0, +SIZE) → world (-sin(a)*SIZE, +cos(a)*SIZE)
    const ex = lander.x - Math.sin(lander.angle) * LANDER_SIZE;
    const ey = lander.y + Math.cos(lander.angle) * LANDER_SIZE;
    spawnThrustParticles(ex, ey, lander.angle);
  }

  lander.x += lander.vx;
  lander.y += lander.vy;

  // Camera — zoom out if lander is near edges or above screen
  updateCamera();

  // Collision
  checkLanding();

  // Particles
  updateParticles();

  // Audio
  updateThrustSound(lander.thrusting);
}

function updateCamera() {
  const W = canvas.width;
  const H = canvas.height;
  const margin = 80;

  // Calculate how much we need to zoom out to keep the lander visible
  // We want the lander to always be within the viewport with some margin
  let needZoomX = 1;
  let needZoomY = 1;

  // How far is the lander from center in each axis?
  const cx = W / 2;
  const cy = H / 2;
  const dx = Math.abs(lander.x - cx);
  const dy = Math.max(0, cy - lander.y); // only care if lander is above center

  // If lander goes beyond the normal viewport, zoom out
  const maxVisX = (W / 2) - margin;
  const maxVisY = (H / 2) - margin;

  if (dx > maxVisX) {
    needZoomX = maxVisX / dx;
  }
  if (lander.y < margin) {
    needZoomY = (H / 2 - margin) / (H / 2 - lander.y + margin);
  }

  camera.targetZoom = Math.min(1, Math.min(needZoomX, needZoomY));
  camera.targetZoom = Math.max(0.15, camera.targetZoom); // don't zoom out too far

  // Smooth interpolation
  camera.zoom += (camera.targetZoom - camera.zoom) * 0.05;

  // Camera centers on midpoint between lander and terrain center when zoomed out
  if (camera.zoom < 0.98) {
    camera.x += ((lander.x - cx) * 0.3 - camera.x) * 0.05;
    camera.y += ((lander.y - cy) * 0.3 - camera.y) * 0.05;
  } else {
    camera.x *= 0.95;
    camera.y *= 0.95;
  }
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.01; // slight gravity on particles
    p.life -= p.decay;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

// ─── Render ──────────────────────────────────────────────────────────
function render() {
  const W = canvas.width;
  const H = canvas.height;
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, W, H);

  if (state === 'title') {
    drawStarsStatic();
    ctx.globalAlpha = 1;
    drawTitle();
    return;
  }

  if (state === 'gameOver') {
    // Draw the scene behind the game over screen
    drawStars();
    ctx.save();
    const goCx = canvas.width / 2;
    const goCy = canvas.height / 2;
    ctx.translate(goCx, goCy);
    ctx.scale(camera.zoom, camera.zoom);
    ctx.translate(-goCx - camera.x, -goCy - camera.y);
    drawTerrain();
    drawLandingPads();
    drawParticles();
    ctx.restore();
    // Darken overlay
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    drawGameOver();
    return;
  }

  // Stars (drawn in screen space, not affected by camera)
  drawStars();

  // Apply camera transform for world objects
  ctx.save();
  const cx = canvas.width / 2;
  const cy = canvas.height / 2;
  ctx.translate(cx, cy);
  ctx.scale(camera.zoom, camera.zoom);
  ctx.translate(-cx - camera.x, -cy - camera.y);

  // Terrain
  drawTerrain();

  // Landing pads
  drawLandingPads();

  // Particles
  drawParticles();

  // Boundary lines
  drawBoundary();

  // Lander
  if (state !== 'crashed') drawLander();

  ctx.restore();

  // HUD (screen space)
  drawHUD();

  // Messages (screen space)
  if (state === 'landed') drawMessage('LANDED!', '#44ff88', 'SPACE for next level');
  if (state === 'crashed') drawMessage('CRASHED!', '#ff4444', `LIVES: ${lives}  —  SPACE to retry`);
}

function drawStarsStatic() {
  // Simpler stars for title
  const rng = mulberry32(42);
  ctx.fillStyle = '#fff';
  for (let i = 0; i < 150; i++) {
    const x = rng() * canvas.width;
    const y = rng() * canvas.height;
    const s = rng() * 1.5 + 0.5;
    ctx.globalAlpha = rng() * 0.5 + 0.5;
    ctx.fillRect(x, y, s, s);
  }
  ctx.globalAlpha = 1;
}

function drawTitle() {
  const cx = canvas.width / 2;
  const cy = canvas.height / 2;

  ctx.textAlign = 'center';
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 48px monospace';
  ctx.fillText('MOONLANDER', cx, cy - 40);

  ctx.font = '16px monospace';
  ctx.fillStyle = '#888';
  ctx.fillText('Arrow keys or WASD to fly', cx, cy + 20);
  ctx.fillText('Land gently on the pads', cx, cy + 45);
  ctx.fillText(`High score: ${highScore}`, cx, cy + 70);

  ctx.fillStyle = '#44ff88';
  ctx.font = '20px monospace';
  const blink = Math.sin(Date.now() / 400) > 0;
  if (blink) ctx.fillText('PRESS SPACE TO START', cx, cy + 120);
}

function drawBoundary() {
  const W = canvas.width;
  const H = canvas.height;
  const bLeft = -W * BOUNDARY_MARGIN;
  const bRight = W * (1 + BOUNDARY_MARGIN);
  const bTop = -H * BOUNDARY_MARGIN;

  // Pulsing red with dashes
  const pulse = 0.3 + Math.sin(Date.now() / 200) * 0.2;
  ctx.strokeStyle = `rgba(255, 50, 50, ${pulse})`;
  ctx.lineWidth = 2;
  ctx.setLineDash([10, 10]);

  ctx.beginPath();
  // Left boundary
  ctx.moveTo(bLeft, bTop);
  ctx.lineTo(bLeft, H * 4);
  // Right boundary
  ctx.moveTo(bRight, bTop);
  ctx.lineTo(bRight, H * 4);
  // Top boundary
  ctx.moveTo(bLeft, bTop);
  ctx.lineTo(bRight, bTop);
  ctx.stroke();

  ctx.setLineDash([]);

  // "OUT OF BOUNDS" warning if lander is close to or past boundary
  if (lander && !lander.outOfBounds) {
    const warnDist = W * 0.1;
    const nearLeft = lander.x - bLeft < warnDist;
    const nearRight = bRight - lander.x < warnDist;
    const nearTop = lander.y - bTop < warnDist;
    if (nearLeft || nearRight || nearTop) {
      ctx.fillStyle = `rgba(255, 50, 50, ${0.5 + Math.sin(Date.now() / 150) * 0.3})`;
      ctx.font = 'bold 16px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('WARNING', lander.x, lander.y - 30);
    }
  }

  // Show "LOST CONTROL" when out of bounds
  if (lander && lander.outOfBounds) {
    ctx.fillStyle = `rgba(255, 50, 50, ${0.6 + Math.sin(Date.now() / 100) * 0.4})`;
    ctx.font = 'bold 20px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('CONTROL LOST', lander.x, lander.y - 120);
  }
}

function drawStars() {
  if (!stars) return;
  for (const s of stars) {
    const flicker = 0.8 + Math.sin(Date.now() * 0.001 + s.x) * 0.2;
    ctx.globalAlpha = s.brightness * flicker;
    ctx.fillStyle = '#fff';
    ctx.fillRect(s.x, s.y, s.size, s.size);
  }
  ctx.globalAlpha = 1;
}

function drawTerrain() {
  if (!terrain || terrain.length === 0) return;
  const lastX = terrain[terrain.length - 1].x;
  const firstX = terrain[0].x;
  // Use a large bottom value to cover zoomed-out views
  const bottom = canvas.height * 4;

  ctx.beginPath();
  ctx.moveTo(firstX, terrain[0].y);
  for (let i = 1; i < terrain.length; i++) {
    ctx.lineTo(terrain[i].x, terrain[i].y);
  }
  ctx.lineTo(lastX, bottom);
  ctx.lineTo(firstX, bottom);
  ctx.closePath();

  // Gradient fill
  const grad = ctx.createLinearGradient(0, canvas.height * 0.4, 0, canvas.height);
  grad.addColorStop(0, '#333');
  grad.addColorStop(1, '#111');
  ctx.fillStyle = grad;
  ctx.fill();

  // Outline
  ctx.beginPath();
  ctx.moveTo(terrain[0].x, terrain[0].y);
  for (let i = 1; i < terrain.length; i++) {
    ctx.lineTo(terrain[i].x, terrain[i].y);
  }
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 1.5;
  ctx.stroke();
}

function drawLandingPads() {
  if (!landingPads) return;
  for (const pad of landingPads) {
    // Pad surface
    ctx.fillStyle = '#44ff88';
    ctx.fillRect(pad.x1, pad.y - 2, pad.x2 - pad.x1, 4);

    // Blinking markers
    const blink = Math.sin(Date.now() / 300) > 0;
    if (blink) {
      ctx.fillStyle = '#ff4444';
      ctx.fillRect(pad.x1, pad.y - 5, 3, 5);
      ctx.fillRect(pad.x2 - 3, pad.y - 5, 3, 5);
    }

    // Arrow above pad
    ctx.save();
    ctx.translate(pad.cx, pad.y - 40 + Math.sin(Date.now() / 500) * 5);
    ctx.fillStyle = 'rgba(68,255,136,0.4)';
    ctx.beginPath();
    ctx.moveTo(0, 10);
    ctx.lineTo(-6, 0);
    ctx.lineTo(6, 0);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }
}

function drawLander() {
  if (!lander) return;
  ctx.save();
  ctx.translate(lander.x, lander.y);
  ctx.rotate(lander.angle);

  // Body
  ctx.fillStyle = '#ddd';
  ctx.beginPath();
  ctx.moveTo(0, -LANDER_SIZE);
  ctx.lineTo(-LANDER_SIZE * 0.7, LANDER_SIZE * 0.5);
  ctx.lineTo(LANDER_SIZE * 0.7, LANDER_SIZE * 0.5);
  ctx.closePath();
  ctx.fill();

  // Window
  ctx.fillStyle = '#4488ff';
  ctx.beginPath();
  ctx.arc(0, -LANDER_SIZE * 0.3, LANDER_SIZE * 0.25, 0, Math.PI * 2);
  ctx.fill();

  // Legs
  ctx.strokeStyle = '#aaa';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(-LANDER_SIZE * 0.5, LANDER_SIZE * 0.5);
  ctx.lineTo(-LANDER_SIZE * 0.8, LANDER_SIZE);
  ctx.moveTo(LANDER_SIZE * 0.5, LANDER_SIZE * 0.5);
  ctx.lineTo(LANDER_SIZE * 0.8, LANDER_SIZE);
  ctx.stroke();

  // Foot pads
  ctx.fillStyle = '#aaa';
  ctx.fillRect(-LANDER_SIZE * 0.95, LANDER_SIZE - 1, LANDER_SIZE * 0.3, 3);
  ctx.fillRect(LANDER_SIZE * 0.65, LANDER_SIZE - 1, LANDER_SIZE * 0.3, 3);

  // Thrust flame
  if (lander.thrusting && state === 'playing') {
    const flicker = Math.random() * 8 + 8;
    const grad = ctx.createLinearGradient(0, LANDER_SIZE * 0.5, 0, LANDER_SIZE * 0.5 + flicker);
    grad.addColorStop(0, '#ffcc00');
    grad.addColorStop(0.5, '#ff6600');
    grad.addColorStop(1, 'rgba(255,0,0,0)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.moveTo(-LANDER_SIZE * 0.3, LANDER_SIZE * 0.5);
    ctx.lineTo(LANDER_SIZE * 0.3, LANDER_SIZE * 0.5);
    ctx.lineTo(0, LANDER_SIZE * 0.5 + flicker);
    ctx.closePath();
    ctx.fill();
  }

  ctx.restore();
}

function drawParticles() {
  for (const p of particles) {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color || '#ff8800';
    ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
  }
  ctx.globalAlpha = 1;
}

function drawHUD() {
  const margin = 15;
  ctx.textAlign = 'left';
  ctx.font = '14px monospace';
  ctx.fillStyle = '#888';
  ctx.fillText(`LEVEL ${level}`, margin, margin + 14);
  ctx.fillText(`SCORE ${score}`, margin, margin + 32);
  ctx.fillText(`HI ${highScore}`, margin, margin + 50);

  // Lives display as lander icons
  ctx.fillStyle = '#fff';
  ctx.fillText('LIVES', margin, margin + 68);
  for (let i = 0; i < lives; i++) {
    const lx = margin + 60 + i * 20;
    const ly = margin + 63;
    ctx.save();
    ctx.translate(lx, ly);
    ctx.fillStyle = '#ddd';
    ctx.beginPath();
    ctx.moveTo(0, -6);
    ctx.lineTo(-4, 3);
    ctx.lineTo(4, 3);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  if (state === 'playing' && lander) {
    ctx.textAlign = 'right';
    const vx = Math.abs(lander.vx).toFixed(1);
    const vy = Math.abs(lander.vy).toFixed(1);
    const angle = (lander.angle * 180 / Math.PI).toFixed(0);

    // Color code velocities
    ctx.fillStyle = Math.abs(lander.vx) > MAX_SAFE_VX ? '#ff4444' : '#44ff88';
    ctx.fillText(`VX ${vx}`, canvas.width - margin, margin + 14);

    ctx.fillStyle = Math.abs(lander.vy) > MAX_SAFE_VY ? '#ff4444' : '#44ff88';
    ctx.fillText(`VY ${vy}`, canvas.width - margin, margin + 32);

    ctx.fillStyle = Math.abs(lander.angle) > MAX_SAFE_ANGLE ? '#ff4444' : '#44ff88';
    ctx.fillText(`ANG ${angle}°`, canvas.width - margin, margin + 50);
  }
}

function drawGameOver() {
  const cx = canvas.width / 2;
  const cy = canvas.height / 2;

  ctx.textAlign = 'center';
  ctx.fillStyle = '#ff4444';
  ctx.font = 'bold 52px monospace';
  ctx.fillText('GAME OVER', cx, cy - 40);

  ctx.fillStyle = '#888';
  ctx.font = '18px monospace';
  ctx.fillText(`Final Score: ${score}`, cx, cy + 10);
  ctx.fillText(`High Score: ${highScore}`, cx, cy + 38);
  ctx.fillText(`Reached Level ${level}`, cx, cy + 66);

  if (score === highScore && score > 0) {
    ctx.fillStyle = '#44ff88';
    ctx.fillText('NEW HIGH SCORE!', cx, cy + 94);
  }

  const blink = Math.sin(Date.now() / 400) > 0;
  if (blink) {
    ctx.fillStyle = '#ccc';
    ctx.font = '20px monospace';
    ctx.fillText('PRESS SPACE', cx, cy + 130);
  }
}

function drawMessage(text, color, sub) {
  const cx = canvas.width / 2;
  const cy = canvas.height / 2;

  ctx.textAlign = 'center';
  ctx.font = 'bold 40px monospace';
  ctx.fillStyle = color;
  ctx.fillText(text, cx, cy - 20);

  ctx.font = '16px monospace';
  ctx.fillStyle = '#888';

  if (state === 'landed') {
    ctx.fillText(`Level bonus: ${level * 100}`, cx, cy + 15);
  }

  const blink = Math.sin(Date.now() / 400) > 0;
  if (blink) {
    ctx.fillStyle = '#ccc';
    ctx.fillText(sub, cx, cy + 50);
  }
}

// ─── Game Loop ───────────────────────────────────────────────────────
function loop() {
  update();
  render();
  requestAnimationFrame(loop);
}

stars = generateStars();
requestAnimationFrame(loop);
</script>
</body>
</html>
